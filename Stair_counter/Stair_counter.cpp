#include <iostream>
#include <locale>
#include <stdexcept>
#include <fstream>

using namespace std;

/*!
* \Проверить полученные из файла данные на соответствие требованиям
* \return - число кубиков, если данные корректны
*/
int inputCheck() 
{
	// Получить полное имя файла с входными данными
	string path_to_input_file; // Полное имя файла
	cout << "Введите полное имя файла с входными данными" << std::endl;
	cin >> path_to_input_file;

	// Проверить расширение файла
	size_t pos = path_to_input_file.rfind('.');
	if (path_to_input_file.substr(pos + 1, string::npos) != "txt")
		throw runtime_error("Неверно указано расширение файла. Файл должен иметь расширение .txt.");

	//Проверить существование файла
	ifstream input(path_to_input_file);
	if (!input.is_open())
	{
		throw runtime_error("Неверно указан файл с входными данными. Возможно, файл не существует.");
	}

	char ch; // Проверяемый символ из файла
	int prev_num = 0; // Последний проверенный символ - цифра
	int found_num = 0; // Найдено число 
	int float_num = 0; // Найдена точка после цифры
	int is_empty = 0; // Файл пуст

	// Проверить содержание файла на корректность
	while (input >> ch)
	{
		is_empty = 1; // Файл не пуст

		// Если проверяемый символ является недопустимым, или допустимый символ располагается в неккоректном месте...
		if (((ch > '9') || (ch < '0')) && 
			((ch != '.')||(ch == '.' && !prev_num)) && 
			((ch != '-')||(ch == '-' && found_num)) &&
			(float_num && !prev_num) &&
			(ch != ' ') && (ch != '\n'))
		{
			// Выдать ошибку
			printf_s("Входное значение «%c» является недопустимым символом.", ch);
			throw runtime_error("");
		}

		// Если проверяемый символ - цифра
		if (ch >= '0' && ch <= '9' && !float_num)
		{
			found_num = 1; // Найденно число
			prev_num = 1; // Последний проверенный символ - цифра
		}
		else
			prev_num = 0; // Последний проверяемый символ - не цифра

		// Если проверяемый символ - цифра, и предыдущий символ - точка после цифры
		if (ch >= '0' && ch <= '9' && float_num)
		{
			// Найденное число - нецелое, выдать ошибку
			throw runtime_error("Входное значение не является целым.");
		}

		// Если проверяемый символ - точка, и последний проверенный символ - цифра
		if (ch == '.' && prev_num)
		{
			// Найдена точка после цифры
			float_num = 1;
		}
	}

	// Если файл оказался пуст
	if (!is_empty)
	{
		// Выдать ошибку
		throw runtime_error("Отсутствует входное значение.");
	}

	// Получить число из файла
	ifstream input_1(path_to_input_file);
	int num = 0;
	input_1 >> num;

	// Если число вне допустимого диапазона
	if (num <= 0 || num > 100)
	{
		// Выдать ошибку
		printf_s("Входное значение %d не принадлежит диапазону (1 .. 100).", num);
		throw runtime_error("");
	}
	// Вернуть полученное число
	return num;
}

/*!
* \ Подсчитать кол-во вариантов лесенок, которые можно составить из n кубиков
* \param[in] prev_level - число кубиков на прошлом уровне лесенки, т.е. число кубиков на первом уровне составляемой лесенки должно быть
*                         меньше этого числа
* \param[in] n - число кубиков, из которых может быть составлена лесенка, (0, 100]
*/
int get_count(int prev_level, int n) 
{
	// Если кубики закончились
	if (0 == n)
		return 1; // Лесенка полностью сгенерирована

	// Обнулить счётчик лесенок
	int count = 0;

	// Для каждого возможного кол-ва кубиков на текущем уровне
	for (int level = 1; level < prev_level; ++level) {
		// Если кубики закончились
		if ((n - level) < 0)
			break; // Завершить цикл
		// Посчитать кол-во вариантов лесенки, которую можно построить из оставшихся кубиков и прибавить посчитанное число к счётчику лесенок
		count += get_count(level, n - level);
	}
	// Вывести кол-во лесенок
	return count;
}

int main() 
{
	setlocale(LC_ALL, "Russian");

	try
	{
		int n; // Кол-во кубиков
		// Получить число кубиков из файла, если содержимое файла допустимо
		n = inputCheck();

		// Посчитать кол-во лесенок и записать результат в файл
		ofstream ofst("output.txt");
		ofst << get_count(n + 1, n);
	}
	catch (exception& ex)
	{
		cout << ex.what() << endl;
	}
}